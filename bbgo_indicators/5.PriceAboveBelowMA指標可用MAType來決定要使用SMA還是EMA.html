<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>5.PriceAboveBelowMA指標可用MAType來決定要使用SMA還是EMA</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><h2 id="priceabovebelowma指標可用matype來決定要使用sma還是ema">PriceAboveBelowMA指標可用MAType來決定要使用SMA還是EMA</h2>
<p>涵蓋以下章節</p>
<ul>
<li>指標程式碼</li>
<li>在策略檔調用此指標</li>
</ul>
<h3 id="指標程式碼：">指標程式碼：</h3>
<pre><code>package indicator

import (
	"time"

	"github.com/c9s/bbgo/pkg/datatype/floats"
	"github.com/c9s/bbgo/pkg/types"
)

const MaxNumOfPriceAboveBelowMA = 5_000
const MaxNumOfPriceAboveBelowMATruncateSize = 100

//go:generate callbackgen -type PriceAboveBelowMA
type PriceAboveBelowMA struct {
	Values          floats.Slice
	updateCallbacks []func(value float64)
	types.IntervalWindow
	EndTime time.Time
	types.SeriesBase

	// Ma type for using SMA or EWMA
	MAType string
	maEWMA *EWMA
	maSMA  *SMA
}

func (inc *PriceAboveBelowMA) Last(i int) float64 {
	return inc.Values.Last(i)
}

func (inc *PriceAboveBelowMA) Index(i int) float64 {
	return inc.Last(i)
}

func (inc *PriceAboveBelowMA) Length() int {
	return len(inc.Values)
}

var _ types.SeriesExtend = &amp;PriceAboveBelowMA{}

func (inc *PriceAboveBelowMA) Update(value float64) {
	// indicator calculation here...
	// push value...

	if len(inc.Values) == 0 {
		switch inc.MAType {
		case "SMA":
			inc.maSMA = &amp;SMA{IntervalWindow: types.IntervalWindow{Window: inc.Window, Interval: inc.Interval}}
		case "EWMA", "EMA":
			inc.maEWMA = &amp;EWMA{IntervalWindow: types.IntervalWindow{Window: inc.Window, Interval: inc.Interval}}
		default:
			// default we use EWMA
			// if outside didn't assign ma type, then use EWMA
			inc.maEWMA = &amp;EWMA{IntervalWindow: types.IntervalWindow{Window: inc.Window, Interval: inc.Interval}}

		}
	}

	var ma float64
	switch inc.MAType {
	case "SMA":
		inc.maSMA.Update(value)
		ma = inc.maSMA.Last(0)
	case "EWMA", "EMA":
		inc.maEWMA.Update(value)
		ma = inc.maEWMA.Last(0)
	default:
		inc.maEWMA.Update(value)
		ma = inc.maEWMA.Last(0)
	}

	if value &gt; ma {
		inc.Values.Push(1)

	} else if value &lt; ma {
		inc.Values.Push(-1)
	} else {
		inc.Values.Push(0)
	}

	if len(inc.Values) &gt; MaxNumOfPriceAboveBelowMA {
		inc.Values = inc.Values[MaxNumOfPriceAboveBelowMATruncateSize-1:]
	}
}

func (inc *PriceAboveBelowMA) PushK(k types.KLine) {

	if inc.EndTime != zeroTime &amp;&amp; k.EndTime.Before(inc.EndTime) {
		return
	}

	inc.Update(k.Close.Float64())
	inc.EndTime = k.EndTime.Time()
	inc.EmitUpdate(inc.Values.Last(0))
}

// 這樣外部可以以收盤價的K線來bind
func (inc *PriceAboveBelowMA) BindK(target KLineClosedEmitter, symbol string, interval types.Interval) {
	target.OnKLineClosed(types.KLineWith(symbol, interval, inc.PushK))
}

// 在外部載入K線
func (inc *PriceAboveBelowMA) LoadK(allKLines []types.KLine) {
	for _, k := range allKLines {
		inc.PushK(k)
	}
}
</code></pre>
<h3 id="在策略檔調用此指標：">在策略檔調用此指標：</h3>
<ol>
<li>
<p>用原先的方式調用，不填寫MAType參數<br>
指標會直接用EWMA作為價格大於小於MA的判斷</p>
<p>主要是這一行只有給IntervalWindow參數</p>
<pre><code>s.PriceAboveBelowMA = &amp;indicator.PriceAboveBelowMA{IntervalWindow: priceAboveBelowMAiw}	
</code></pre>
<p>完整調用方式如下：<br>
(1)在Run()</p>
<pre><code>priceAboveBelowMAiw := types.IntervalWindow{Window: s.Window, Interval: s.Interval}
s.PriceAboveBelowMA = &amp;indicator.PriceAboveBelowMA{IntervalWindow: priceAboveBelowMAiw}
s.PriceAboveBelowMA.BindK(session.MarketDataStream, s.Symbol, s.Interval)
kLineStore, _ := session.MarketDataStore(s.Symbol)
if klines, ok := kLineStore.KLinesOfInterval(s.Interval); ok {
	s.PriceAboveBelowMA.LoadK((*klines)[0:])
}
s.PriceAboveBelowMA.OnUpdate(func(v float64) {
	// There are three possible outcomes of this indicator: 0, 1, -1
	// 0 stands price equals ma; 1 stands price above ma; -1 stands price below ma
	fmt.Println("PriceAboveBelowMA: ", v)
})
</code></pre>
<p>(2)在OnKLineClosed()</p>
<pre><code>indValue := s.PriceAboveBelowMA.Last(0)
if indValue == 1 {
	fmt.Printf("價格大於%v %v%v, endTime:%v\n", s.Interval, s.PriceAboveBelowMA.MAType, s.Window, s.PriceAboveBelowMA.EndTime)
}
if indValue == -1 {
	fmt.Printf("價格小於%v %v%v, endTime:%v\n", s.Interval, s.PriceAboveBelowMA.MAType, s.Window, s.PriceAboveBelowMA.EndTime)
}	
</code></pre>
</li>
<li>
<p>如果帶入MAType參數可自由指定要用SMA還是EWMA(填EWMA或EMA都可以)</p>
<p>主要是這一行新增了參數與值MAType: “SMA”</p>
<pre><code>s.PriceAboveBelowMA  =  &amp;indicator.PriceAboveBelowMA{IntervalWindow: priceAboveBelowMAiw, MAType: "SMA"}
</code></pre>
<p>完整調用方式如下：<br>
(1)在Run()</p>
<pre><code>priceAboveBelowMAiw := types.IntervalWindow{Window: s.Window, Interval: s.Interval}
s.PriceAboveBelowMA = &amp;indicator.PriceAboveBelowMA{IntervalWindow: priceAboveBelowMAiw, MAType: "SMA"}
s.PriceAboveBelowMA.BindK(session.MarketDataStream, s.Symbol, s.Interval)
kLineStore, _ := session.MarketDataStore(s.Symbol)
if klines, ok := kLineStore.KLinesOfInterval(s.Interval); ok {
	s.PriceAboveBelowMA.LoadK((*klines)[0:])
}
s.PriceAboveBelowMA.OnUpdate(func(v float64) {
	// There are three possible outcomes of this indicator: 0, 1, -1
	// 0 stands price equals ma; 1 stands price above ma; -1 stands price below ma
	fmt.Println("PriceAboveBelowMA: ", v)
})
</code></pre>
<p>(2)在OnKLineClosed()</p>
<pre><code>indValue := s.PriceAboveBelowMA.Last(0)
if indValue == 1 {
	fmt.Printf("價格大於%v %v%v, endTime:%v\n", s.Interval, s.PriceAboveBelowMA.MAType, s.Window, s.PriceAboveBelowMA.EndTime)
}
if indValue == -1 {
	fmt.Printf("價格小於%v %v%v, endTime:%v\n", s.Interval, s.PriceAboveBelowMA.MAType, s.Window, s.PriceAboveBelowMA.EndTime)
}
</code></pre>
</li>
</ol>
<blockquote>
<p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p>
</blockquote>
</div>
</body>

</html>
