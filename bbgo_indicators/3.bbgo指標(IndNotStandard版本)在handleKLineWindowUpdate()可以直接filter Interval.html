<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3.bbgo指標(IndNotStandard版本)在handleKLineWindowUpdate()可以直接filter Interval</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><h2 id="bbgo指標indnotstandard版本在handleklinewindowupdate可以直接filter-interval">bbgo指標(IndNotStandard版本)在handleKLineWindowUpdate()可以直接filter Interval</h2>
<ol>
<li>
<p>標題說</p>
<p>bbgo指標(IndNotStandard版本)在handleKLineWindowUpdate()可以直接filter Interval<br>
所以Bind()、CalculateAndUpdate()、handleKLineWindowUpdate()<br>
這三個方法的組合在計算指標上還是可行的，我之前以為不行<br>
以為K線接收一定會是：</p>
<p>1m<br>
1m<br>
1m<br>
1m<br>
1m<br>
5m</p>
</li>
<li>
<p>現在加入filter邏輯後：</p>
<p>不是我們要的時框之K線值，就不動作<br>
是我們指定時框之K線，才進入CalculateAndUpdate()<br>
以這個例子而言，也就是我們只在拿到5m時框K線時才去處理<br>
然後我們有三種方式可以去filer inteval</p>
<pre><code>func (inc *PriceCrossMa) handleKLineWindowUpdate(interval types.Interval, window types.KLineWindow) {

	// Three ways of filter on interval
	// (1)Use this PriceCrossMa indicator's interval
	if interval != inc.Interval {
		return
	}

	// (2)Use the interval of the types.IntervalWindow
	// filteriw := types.IntervalWindow{Window: 20, Interval: "5m"}
	// if interval != filteriw.Interval {
	// 	return
	// }

	// (3)Use the interval of the types.Interval
	// var i types.Interval = "5m"
	// if interval != i {
	// 	return
	// }
	inc.CalculateAndUpdate(window)
}
</code></pre>
</li>
<li>
<p>而在策略檔的Run()，我們就可以用回market data store + Bind()來調用指標</p>
<pre><code>priceCrossMaiw := types.IntervalWindow{Window: 20, Interval: s.Interval}
s.priceCrossMa = &amp;indicator.PriceCrossMa{IntervalWindow: priceCrossMaiw}

symbol := s.Symbol
store, _ := session.MarketDataStore(symbol)
s.priceCrossMa.Bind(store)

s.priceCrossMa.OnUpdate(func(v float64) {
	fmt.Println("priceCrossMa: ", v)
})
</code></pre>
</li>
<li>
<p>問題思考：在bbgo run時，是否會因為不同的方式而導致問題<br>
Bind()用到的KLineWindowUpdater的OnKLineWindowUpdate，在bbgo backtest時每m5會拿到一次資料<br>
BindK()用到的KLineClosedEmitter的OnKLineClosed，看名稱就知道是拿m5收線資料</p>
<p>因為我現在都是用bbgo backtest<br>
所以Bind()+filter inteval 與 BindK 這兩種方式最後計算出的指標值會一致<br>
但我的問題是<br>
bbgo run時，用Bind()+filter inteval會不會有問題啊<br>
如果拿到即時的資料而不是收盤價，就會有問題</p>
<pre><code>func (inc *PriceCrossMa) Bind(updater KLineWindowUpdater) {
	updater.OnKLineWindowUpdate(inc.handleKLineWindowUpdate)
}
// 這樣外部可以以收盤價的K線來bind
func (inc *PriceCrossMa) BindK(target KLineClosedEmitter, symbol string, interval types.Interval) {
	target.OnKLineClosed(types.KLineWith(symbol, interval, inc.PushK))
}
</code></pre>
</li>
<li>
<p>我用bbgo run試跑了Bind()+filter inteval的方式</p>
<p>第一個m5時間點的輸出訊息：<br>
看起來是指標的OnUpdate()在那個時間點被觸發多次，然後也包含最近一次的sma值</p>
<pre><code>....................
priceCrossMa:  42818.206999999995
priceCrossMa:  42812.640999999996
priceCrossMa:  42806.7935
priceCrossMa:  42802.3665
priceCrossMa:  42798.445
982 PriceCrossMa sma len | value: 42798.445
982 官方sma len          | value: 42798.445
</code></pre>
<p>第二個m5時間點的輸出訊息：<br>
這次OnUpdate()就只輸出最新的指標值</p>
<pre><code>priceCrossMa:  42793.231
983 PriceCrossMa sma len | value: 42793.231
983 官方sma len          | value: 42793.231
</code></pre>
</li>
<li>
<p>我用bbgo run試跑了BindK()、LoadK()方式<br>
第一個m5時間點的輸出訊息：<br>
看起來還是BindK()、LoadK()方式比較好<br>
就算是第一個m5時間點，OnUpdate()只輸出這次的指標值<br>
輸出一大堆之前的指標值感覺還滿困擾人的</p>
<pre><code>priceCrossMa:  42783.481999999996
982 PriceCrossMa sma len | value: 42783.481999999996
982 官方sma len          | value: 42783.481999999996
</code></pre>
</li>
</ol>
<blockquote>
<p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p>
</blockquote>
</div>
</body>

</html>
