<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>7.調用StandardIndicatorSet裡的指標的同時，註明symbol，因此可使用預設symbol之外的交易對</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><h2 id="調用standardindicatorset裡的指標的同時，註明symbol，因此可使用預設symbol之外的交易對">調用StandardIndicatorSet裡的指標的同時，註明symbol，因此可使用預設symbol之外的交易對</h2>
<h3 id="在standardindicatorset的指標有：">在StandardIndicatorSet的指標有：</h3>
<pre><code>1. SMA 2. EWMA 3. VWMA 4. PivotHigh 5. PivotLow 6. ATR 7. ATRP 8. EMV 9. CCI 10. HULL 11. STOCH 12. BOLL 13. MACD 14. RSI 15. GHFilter 16. KalmanFilter
</code></pre>
<h3 id="幾個重點：">幾個重點：</h3>
<ol>
<li>
<p>我們這次要拿預設的symbol算指標值、也要拿預設外的symbol算指標值，在struct宣告兩個SMA變數：</p>
<pre><code>type Strategy struct {
	......
	// 調用在StandardIndicatorSet裡的指標，還是要用指標本身的struct來接
	SMA  *indicator.SMA
	SMA2 *indicator.SMA
}
</code></pre>
</li>
<li>
<p>訂閱預設的symbol與預設外的symbol的K線資料</p>
<pre><code>func (s *Strategy) Subscribe(session *bbgo.ExchangeSession) {
	// session.Subscribe(types.KLineChannel, s.Symbol, types.SubscribeOptions{Interval: s.Interval})
	session.Subscribe(types.KLineChannel, s.Symbol, types.SubscribeOptions{Interval: "5m"})

	// 特別訂閱MATICUSDT的kline
	session.Subscribe(types.KLineChannel, "MATICUSDT", types.SubscribeOptions{Interval: "5m"})
}
</code></pre>
</li>
<li>
<p>在Run()，使用session的StandardIndicatorSet()必須填寫symbol，再調用SMA()傳入inteval與window參數<br>
我們這裡示範在同一份策略檔，計算兩種symbol的SMA指標值</p>
<pre><code>s.SMA = session.StandardIndicatorSet(s.Symbol).SMA(types.IntervalWindow{Interval: s.Interval, Window: s.Window})
s.SMA2 = session.StandardIndicatorSet("MATICUSDT").SMA(types.IntervalWindow{Interval: s.Interval, Window: s.Window})

s.SMA.OnUpdate(func(v float64) {
	fmt.Println("BTCUSDT官方sma: ", v)
})
s.SMA2.OnUpdate(func(v float64) {
	fmt.Println("MATICUSDT官方sma: ", v)
})
</code></pre>
</li>
<li>
<p>在session.MarketDataStream.OnKLineClosed(</p>
<pre><code>fmt.Println("BTCUSDT官方sma with Last(0): ", s.SMA.Last(0))
fmt.Println("MATICUSDT官方sma with Last(0): ", s.SMA2.Last(0))
fmt.Println()
</code></pre>
</li>
<li>
<p>要注意的是，我目前跑的是bbgo backtest，所以yaml檔backtest區塊底下的symbols區塊，也要把預設外的symbol填上去，這邊是以MATICUSDT為例</p>
<pre><code>exchangeStrategies:
- on: binance
  getIndStandard:
    symbol: BTCUSDT
    interval: 5m
    window: 60
   
backtest:
  startTime: "2023-12-21"
  endTime: "2023-12-22"
  symbols:
  - BTCUSDT
  - MATICUSDT
  sessions: [binance]
  # syncSecKLines: true
  accounts:
    binance:
      makerFeeRate: 0.0%
      takerFeeRate: 0.075%
      balances:
        BTC: 0.0
        USDT: 10_000.0
</code></pre>
</li>
</ol>
<h3 id="完整策略檔程式碼">完整策略檔程式碼</h3>
<pre><code>package getIndStandard

import (
	"context"
	"fmt"

	"github.com/c9s/bbgo/pkg/bbgo"
	"github.com/c9s/bbgo/pkg/indicator"
	"github.com/c9s/bbgo/pkg/types"
)

const ID = "getIndStandard"

func init() {
	// Register our struct type to BBGO
	// Note that you don't need to field the fields.
	// BBGO uses reflect to parse your type information.
	bbgo.RegisterStrategy(ID, &amp;Strategy{})
}

type Strategy struct {
	Symbol   string         `json:"symbol"`
	Interval types.Interval `json:"interval"`
	Window   int            `json:"window"`

	// 調用在StandardIndicatorSet裡的指標，還是要用指標本身的struct來接
	SMA  *indicator.SMA
	SMA2 *indicator.SMA
}

func (s *Strategy) ID() string {
	return ID
}

// func (s *Strategy) InstanceID() string {
// 	return fmt.Sprintf("%s:%s:%s", ID, s.Symbol, s.Interval)
// }

func (s *Strategy) Subscribe(session *bbgo.ExchangeSession) {
	// session.Subscribe(types.KLineChannel, s.Symbol, types.SubscribeOptions{Interval: s.Interval})
	session.Subscribe(types.KLineChannel, s.Symbol, types.SubscribeOptions{Interval: "5m"})

	// 特別訂閱MATICUSDT的kline
	session.Subscribe(types.KLineChannel, "MATICUSDT", types.SubscribeOptions{Interval: "5m"})
}

func (s *Strategy) Run(ctx context.Context, orderExecutor bbgo.OrderExecutor, session *bbgo.ExchangeSession) error {

	// 位於StandardIndicatorSet裡的指標在調用時
	// 不用在策略檔的地方使用Bind()或BindK()+LoadK()方法
	// 初始化完，就可以直接使用OnUpdate()方法或使用指標的Last(i)方法
	// 這邊使用session的StandardIndicatorSet()必須填寫symbol，再調用SMA()，
	// 所以指標與策略yaml的symbol不同，是可以的
	// 意即在同一個策略檔中，可以使用不同的symbol的資料的指標
	// 但要做(1)、(2)的設定，才能正常執行
	// (1)在yaml的backtest區塊加上其他的symbol，我多加了MATICUSDT這個symbol
	// symbols:
	// - BTCUSDT
	// - MATICUSDT
	// (2)在Subscribe()訂閱MATICUSDT的kline
	// session.Subscribe(types.KLineChannel, "MATICUSDT", types.SubscribeOptions{Interval: "5m"})
	s.SMA = session.StandardIndicatorSet(s.Symbol).SMA(types.IntervalWindow{Interval: s.Interval, Window: s.Window})
	s.SMA2 = session.StandardIndicatorSet("MATICUSDT").SMA(types.IntervalWindow{Interval: s.Interval, Window: s.Window})

	s.SMA.OnUpdate(func(v float64) {
		fmt.Println("BTCUSDT官方sma: ", v)
	})
	s.SMA2.OnUpdate(func(v float64) {
		fmt.Println("MATICUSDT官方sma: ", v)
	})

	session.MarketDataStream.OnKLineClosed(types.KLineWith(s.Symbol, s.Interval, func(k types.KLine) {

		fmt.Println("BTCUSDT官方sma with Last(0): ", s.SMA.Last(0))
		fmt.Println("MATICUSDT官方sma with Last(0): ", s.SMA2.Last(0))
		fmt.Println()
	}))
	return nil
}
</code></pre>
<blockquote>
<p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p>
</blockquote>
</div>
</body>

</html>
